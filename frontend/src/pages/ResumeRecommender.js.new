import React, { useState, useEffect, useCallback } from 'react';
import axios from 'axios';
import { 
  Container, 
  Typography, 
  CircularProgress, 
  Alert, 
  Snackbar, 
  Grid, 
  Box,
  Fab,
  useScrollTrigger,
  Zoom,
  Fade,
  Paper,
  Divider,
  Chip,
  Accordion,
  AccordionSummary,
  AccordionDetails
} from '@mui/material';
import { KeyboardArrowUp, ExpandMore, FilterList, Check } from '@mui/icons-material';
import SearchForm from '../components/SearchForm';
import ResumeCard from '../components/ResumeCard.jsx';
import PageHero from '../components/PageHero';
import { alpha } from '@mui/material/styles';

// Debounce function
const useDebounce = (value, delay) => {
  const [debouncedValue, setDebouncedValue] = useState(value);

  useEffect(() => {
    const handler = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);

    return () => {
      clearTimeout(handler);
    };
  }, [value, delay]);

  return debouncedValue;
};

// Scroll-to-top component
function ScrollTop(props) {
  const { children } = props;
  const trigger = useScrollTrigger({
    disableHysteresis: true,
    threshold: 100,
  });

  const handleClick = (event) => {
    const anchor = (event.target.ownerDocument || document).querySelector('#back-to-top-anchor');
    if (anchor) {
      anchor.scrollIntoView({ behavior: 'smooth', block: 'center' });
    }
  };

  return (
    <Zoom in={trigger}>
      <Box
        onClick={handleClick}
        role="presentation"
        sx={{ position: 'fixed', bottom: 16, right: 16 }}
      >
        {children}
      </Box>
    </Zoom>
  );
}

function ResumeRecommender() {
  const [recommendations, setRecommendations] = useState([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);
  const [jobDesc, setJobDesc] = useState("");
  const [topN, setTopN] = useState(5);
  const [recommendationType, setRecommendationType] = useState('traditional');
  const [llmModel, setLlmModel] = useState('llama4');
  const [showLlmDetails, setShowLlmDetails] = useState(false);
  
  const debouncedJobDesc = useDebounce(jobDesc, 300);  // 300ms delay

  // Get recommendations based on selected type and parameters
  const getRecommendations = useCallback(async (params) => {
    setLoading(true);
    setError(null);
    setRecommendations([]);
    setShowLlmDetails(params.recommendationType !== 'traditional');
    
    try {
      // Determine which API endpoint to use based on recommendation type
      let endpoint = "http://localhost:8000/api/recommend/";
      const apiParams = {
        job_description: params.jobDesc,
        top_n: params.topN
      };
      
      if (params.recommendationType === 'hybrid' || params.recommendationType === 'llm_only') {
        endpoint = "http://localhost:8000/api/recommend/llm/";
        apiParams.model = params.llmModel;
        apiParams.recommendation_type = params.recommendationType === 'hybrid' ? 'hybrid' : 'llm_only';
      }
      
      console.log(`Fetching ${params.recommendationType} recommendations using endpoint:`, endpoint);
      const response = await axios.post(endpoint, apiParams);
      
      console.log("API Response:", response.data);
      setRecommendations(response.data);
    } catch (error) {
      console.error("API Error:", error);
      setError("An error occurred while fetching recommendations.");
    } finally {
      setLoading(false);
    }
  }, []);
  
  // Handle form submission
  const handleSearch = useCallback((params) => {
    setJobDesc(params.jobDesc);
    setTopN(params.topN);
    setRecommendationType(params.recommendationType);
    setLlmModel(params.llmModel);
    
    getRecommendations(params);
  }, [getRecommendations]);
  
  // For backward compatibility with the debounced effect
  useEffect(() => {
    if (debouncedJobDesc && recommendationType === 'traditional') {
      console.log("Using debounced recommendations for:", debouncedJobDesc);
      setLoading(true);
      setError(null);
      
      axios.post("http://localhost:8000/api/recommend/", {
        job_description: debouncedJobDesc,
        top_n: topN
      })
        .then((response) => {
          console.log("API Response:", response.data);
          setRecommendations(response.data);
          setLoading(false);
        })
        .catch((error) => {
          console.error("API Error:", error);
          setError("An error occurred while fetching recommendations.");
          setLoading(false);
        });
    }
  }, [debouncedJobDesc, topN, recommendationType]);

  // Close error alert
  const handleCloseError = () => {
    setError(null);
  };
  
  // Format recommendations to be compatible with ResumeCard
  const formatRecommendations = useCallback((recommendations) => {
    return recommendations.map(rec => {
      const formattedResume = {
        ...rec.resume,
        score: rec.score
      };
      
      // Add LLM reasoning as match reasons if available
      if (showLlmDetails) {
        const matchReasons = [];
        
        // Add main reasoning
        if (rec.reasoning || rec.llm_reasoning) {
          matchReasons.push(rec.reasoning || rec.llm_reasoning);
        }
        
        // Add strengths
        if (rec.strengths) {
          rec.strengths.forEach(strength => {
            matchReasons.push(`Strength: ${strength}`);
          });
        }
        
        // Add weaknesses
        if (rec.weaknesses) {
          rec.weaknesses.forEach(weakness => {
            matchReasons.push(`Gap: ${weakness}`);
          });
        }
        
        if (matchReasons.length > 0) {
          formattedResume.match_reasons = matchReasons;
        }
      }
      
      return formattedResume;
    });
  }, [showLlmDetails]);

  return (
    <Box>
      {/* Hero Section */}
      <PageHero 
        title="Resume Recommender" 
        subtitle="Find the best resumes that match your job description" 
      />
      <div id="back-to-top-anchor" />
      
      <Fade in={true} timeout={1000}>
        <Container maxWidth="lg" sx={{ mt: 4, mb: 8 }}>
          <Grid container spacing={4}>
            <Grid item xs={12}>
              <SearchForm 
                onSubmit={handleSearch}
                loading={loading}
              />
            </Grid>
            
            {/* Error alert */}
            {error && (
              <Grid item xs={12}>
                <Alert 
                  severity="error" 
                  onClose={handleCloseError}
                  sx={{ width: '100%' }}
                >
                  {error}
                </Alert>
              </Grid>
            )}
            
            {/* Loading indicator */}
            {loading && (
              <Grid item xs={12} sx={{ textAlign: 'center', py: 8 }}>
                <CircularProgress />
                <Typography variant="body2" sx={{ mt: 2, color: 'text.secondary' }}>
                  {recommendationType !== 'traditional' 
                    ? "AI is analyzing resumes, this might take a moment..."
                    : "Finding matches..."}
                </Typography>
              </Grid>
            )}
            
            {/* Recommendations */}
            {!loading && recommendations.length > 0 && (
              <Grid item xs={12}>
                <Typography variant="h6" sx={{ mb: 3, mt: 2 }}>
                  Found {recommendations.length} matching candidates
                </Typography>
                <Grid container spacing={3}>
                  {formatRecommendations(recommendations).map((resume, index) => (
                    <Grid item key={index} xs={12} md={6} lg={4}>
                      <ResumeCard resume={resume} />
                    </Grid>
                  ))}
                </Grid>
              </Grid>
            )}
            
            {/* No results */}
            {!loading && recommendations.length === 0 && jobDesc && (
              <Grid item xs={12} sx={{ textAlign: 'center', py: 8 }}>
                <Typography variant="h6" color="text.secondary">
                  No matching candidates found
                </Typography>
                <Typography variant="body2" color="text.secondary" sx={{ mt: 1 }}>
                  Try adjusting your job description or search criteria
                </Typography>
              </Grid>
            )}
          </Grid>
        </Container>
      </Fade>

      {/* Scroll-to-top Button */}
      <ScrollTop>
        <Fab color="primary" size="small" aria-label="scroll back to top">
          <KeyboardArrowUp />
        </Fab>
      </ScrollTop>
    </Box>
  );
}

export default ResumeRecommender;
